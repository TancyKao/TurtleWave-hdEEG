

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>turtlewave_hdEEG.eventprocessor &mdash; turtlewave 1.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=fc837d61"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            turtlewave
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">TURTLEWAVE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">nstallation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gui.html">GUI Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">turtlewave</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">turtlewave_hdEEG.eventprocessor</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for turtlewave_hdEEG.eventprocessor</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">csv</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wonambi.trans</span><span class="w"> </span><span class="kn">import</span> <span class="n">select</span><span class="p">,</span> <span class="n">fetch</span><span class="p">,</span> <span class="n">math</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wonambi.attr</span><span class="w"> </span><span class="kn">import</span> <span class="n">Annotations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">turtlewave_hdEEG.extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">ImprovedDetectSpindle</span> <span class="k">as</span> <span class="n">DetectSpindle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>


<div class="viewcode-block" id="ParalEvents">
<a class="viewcode-back" href="../../turtlewave_hdEEG.html#turtlewave_hdEEG.eventprocessor.ParalEvents">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParalEvents</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for parallel detection and analysis of EEG events such as spindles,</span>
<span class="sd">    and other neural events across multiple channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">annotations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">log_level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="n">log_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the ParalEvents object.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataset : Dataset</span>
<span class="sd">            Dataset object containing EEG data</span>
<span class="sd">        annotations : XLAnnotations</span>
<span class="sd">            Annotations object for storing and retrieving events</span>
<span class="sd">        log_level : int</span>
<span class="sd">            Logging level (e.g., logging.DEBUG, logging.INFO)</span>
<span class="sd">        log_file : str or None</span>
<span class="sd">            Path to log file. If None, logs to console only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="o">=</span> <span class="n">annotations</span>
        <span class="c1"># Setup logging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_logger</span><span class="p">(</span><span class="n">log_level</span><span class="p">,</span> <span class="n">log_file</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_level</span><span class="p">,</span> <span class="n">log_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up a logger for the EventProcessor.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_level : int</span>
<span class="sd">            Logging level (e.g., logging.DEBUG, logging.INFO)</span>
<span class="sd">        log_file : str or None</span>
<span class="sd">            Path to log file. If None, logs to console only.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logger : logging.Logger</span>
<span class="sd">            Configured logger instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a logger</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;turtlewave_hdEEG.eventprocessor&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">log_level</span><span class="p">)</span>
        
        <span class="c1"># Create formatter</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> - </span><span class="si">%(name)s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># Create console handler</span>
        <span class="n">console_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
        <span class="n">console_handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">console_handler</span><span class="p">)</span>
        
        <span class="c1"># Create file handler if log_file specified</span>
        <span class="k">if</span> <span class="n">log_file</span><span class="p">:</span>
            <span class="n">file_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">FileHandler</span><span class="p">(</span><span class="n">log_file</span><span class="p">)</span>
            <span class="n">file_handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">file_handler</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">logger</span>


   <span class="c1"># solve the issue of memory leaks by cleaning up large variables and forcing garbage collection</span>
<div class="viewcode-block" id="ParalEvents.clean_memory">
<a class="viewcode-back" href="../../turtlewave_hdEEG.html#turtlewave_hdEEG.eventprocessor.ParalEvents.clean_memory">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clean_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform thorough memory cleanup to release resources</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">gc</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
        
        <span class="c1"># Clear any large variables in the class</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_temp_data&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_data</span>
        
        <span class="c1"># Force garbage collection</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        
        <span class="c1"># For more aggressive cleanup on systems that support it</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;linux&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">resource</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">psutil</span>
                <span class="c1"># Suggest to OS to release memory</span>
                <span class="n">psutil</span><span class="o">.</span><span class="n">Process</span><span class="p">()</span><span class="o">.</span><span class="n">memory_info</span><span class="p">()</span>
                <span class="n">resource</span><span class="o">.</span><span class="n">RUSAGE_SELF</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;psutil not available for advanced memory cleanup&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Memory cleanup performed&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="ParalEvents.detect_spindles">
<a class="viewcode-back" href="../../turtlewave_hdEEG.html#turtlewave_hdEEG.eventprocessor.ParalEvents.detect_spindles">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">detect_spindles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Ferrarelli2007&#39;</span><span class="p">,</span> <span class="n">chan</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ref_chan</span><span class="o">=</span><span class="p">[],</span> <span class="n">grp_name</span><span class="o">=</span><span class="s1">&#39;eeg&#39;</span><span class="p">,</span>
                       <span class="n">frequency</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">duration</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">polar</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> 
                       <span class="n">reject_artifacts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reject_arousals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">stage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">save_to_annotations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">json_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">create_empty_json</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">detector_params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect spindles in the dataset while considering artifacts and arousals.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str or list</span>
<span class="sd">            Detection method(s) to use (&#39;Ferrarelli2007&#39;, &#39;Wamsley2012&#39;, etc.)</span>
<span class="sd">        chan : list or str</span>
<span class="sd">            Channels to analyze</span>
<span class="sd">        ref_chan : list or str</span>
<span class="sd">            Reference channel(s) for re-referencing, or None to use original reference</span>
<span class="sd">        grp_name : str</span>
<span class="sd">            Group name for channel selection</span>
<span class="sd">        frequency : tuple</span>
<span class="sd">            Frequency range for spindle detection (min, max)</span>
<span class="sd">        duration : tuple</span>
<span class="sd">            Duration range for spindle detection in seconds (min, max)</span>
<span class="sd">        polar : str</span>
<span class="sd">            &#39;normal&#39; or &#39;opposite&#39; for handling signal polarity</span>
<span class="sd">        reject_artifacts : bool</span>
<span class="sd">            Whether to exclude segments marked with artifact annotations</span>
<span class="sd">        reject_arousals : bool</span>
<span class="sd">            Whether to exclude segments marked with arousal annotations</span>
<span class="sd">        json_dir : str or None</span>
<span class="sd">            Directory to save individual channel JSON files (one per channel)</span>
<span class="sd">        create_empty_json : bool</span>
<span class="sd">            Whether to create empty JSON files when no spindles are found</span>
<span class="sd">        **detector_params : dict</span>
<span class="sd">        Additional parameters to pass to the detector. These are method-specific</span>
<span class="sd">        and can include parameters like det_thresh, sel_thresh, etc.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of all detected spindles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span> 
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;Whaling it... (searching for spindles)</span>
<span class="s2">                              .</span>
<span class="s2">                           &quot;:&quot;</span>
<span class="s2">                         ___:____     |&quot;\/&quot;|</span>
<span class="s2">                       ,&#39;        `.    \  /</span>
<span class="s2">                       |  O        \___/  |</span>
<span class="s2">                     ~^~^~^~^~^~^~^~^~^~^~^~^~</span>
<span class="s2">                     &quot;&quot;&quot;</span><span class="p">)</span>
                     
        
        <span class="c1"># Configure what to reject</span>
        <span class="n">reject_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">reject_artifacts</span><span class="p">:</span>
            <span class="n">reject_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Artefact&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Configured to reject artifacts&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reject_arousals</span><span class="p">:</span>
            <span class="n">reject_types</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;Arousal&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Configured to reject arousals&quot;</span><span class="p">)</span>

        <span class="c1"># Make sure method is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span>
        
        <span class="c1"># Make sure chan is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">chan</span> <span class="o">=</span> <span class="p">[</span><span class="n">chan</span><span class="p">]</span>
        
        <span class="c1"># Make sure stage is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">stage</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage</span><span class="p">]</span>
        
        <span class="c1"># Create json_dir if specified</span>
        <span class="k">if</span> <span class="n">json_dir</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">json_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel JSONs will be saved to: </span><span class="si">{</span><span class="n">json_dir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Verify that we have all required components</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error: No dataset provided for spindle detection&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">save_to_annotations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Warning: No annotations provided but annotation saving requested.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Spindles will not be saved to annotations.&quot;</span><span class="p">)</span>
            <span class="n">save_to_annotations</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Convert method to string</span>
        <span class="n">method_str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        
        <span class="c1"># Convert frequency to string</span>
        <span class="n">freq_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">frequency</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">frequency</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">Hz&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting spindle detection with method=</span><span class="si">{</span><span class="n">method_str</span><span class="si">}</span><span class="s2">, frequency=</span><span class="si">{</span><span class="n">freq_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameters: channels=</span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s2">, reject_artifacts=</span><span class="si">{</span><span class="n">reject_artifacts</span><span class="si">}</span><span class="s2">, reject_arousals=</span><span class="si">{</span><span class="n">reject_arousals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">detector_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Method-specific parameters: </span><span class="si">{</span><span class="n">detector_params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



        <span class="c1"># Create a custom annotation file name if saving to annotations</span>
        <span class="k">if</span> <span class="n">save_to_annotations</span><span class="p">:</span>
            <span class="c1"># Convert channel list to string</span>
            <span class="n">chan_str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chan</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">_plus_</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">_chans&quot;</span>
            
            
            <span class="c1"># Create custom filename</span>
            <span class="n">annotation_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;spindles_</span><span class="si">{</span><span class="n">method_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">chan_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">freq_str</span><span class="si">}</span><span class="s2">.xml&quot;</span>
             <span class="c1"># Create full path if json_dir is specified</span>
            <span class="k">if</span> <span class="n">json_dir</span><span class="p">:</span>
                <span class="n">annotation_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">json_dir</span><span class="p">,</span> <span class="n">annotation_filename</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use current directory</span>
                <span class="n">annotation_file_path</span> <span class="o">=</span> <span class="n">annotation_filename</span>
                
            <span class="c1"># Create new annotation object if we&#39;re saving to a new file</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Create a copy of the original annota</span>
                    <span class="kn">import</span><span class="w"> </span><span class="nn">shutil</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">,</span> <span class="s1">&#39;xml_file&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">xml_file</span><span class="p">):</span>
                        <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">xml_file</span><span class="p">,</span> <span class="n">annotation_file_path</span><span class="p">)</span>
                        <span class="n">new_annotations</span> <span class="o">=</span> <span class="n">Annotations</span><span class="p">(</span><span class="n">annotation_file_path</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">spindle_events</span> <span class="o">=</span> <span class="n">new_annotations</span><span class="o">.</span><span class="n">get_events</span><span class="p">(</span><span class="s1">&#39;spindle&#39;</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">spindle_events</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spindle_events</span><span class="p">)</span><span class="si">}</span><span class="s2"> existing spindle events&quot;</span><span class="p">)</span>
                                <span class="n">new_annotations</span><span class="o">.</span><span class="n">remove_event_type</span><span class="p">(</span><span class="s1">&#39;spindle&#39;</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Note: No existing spindle events to remove: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># If we can&#39;t copy, create a new annotations file from scratch</span>
                        <span class="c1"># Create minimal XML structure</span>
                        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">annotation_file_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&lt;?xml version=&quot;1.0&quot; ?&gt;</span><span class="se">\n</span><span class="s1">&lt;annotations&gt;&lt;dataset&gt;&lt;filename&gt;&#39;</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">):</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&lt;/filename&gt;&lt;/dataset&gt;&lt;rater&gt;&lt;name&gt;Wonambi&lt;/name&gt;&lt;/rater&gt;&lt;/annotations&gt;&#39;</span><span class="p">)</span>
                        <span class="n">new_annotations</span> <span class="o">=</span> <span class="n">Annotations</span><span class="p">(</span><span class="n">annotation_file_path</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Will save spindles to new annotation file: </span><span class="si">{</span><span class="n">annotation_file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>    

                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating new annotation file: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">save_to_annotations</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">new_annotations</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Warning: No annotations provided but annotation saving requested.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Spindles will not be saved to annotations.&quot;</span><span class="p">)</span>
                <span class="n">save_to_annotations</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">new_annotations</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Store all detected spindles</span>
        <span class="n">all_spindles</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chan</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Reading data for channel </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    
                    <span class="c1"># Fetch segments, filtering based on stage and artifacts</span>
                    <span class="n">segments</span> <span class="o">=</span> <span class="n">fetch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">,</span> <span class="n">cat</span><span class="o">=</span><span class="n">cat</span><span class="p">,</span> <span class="n">stage</span><span class="o">=</span><span class="n">stage</span><span class="p">,</span> <span class="n">cycle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="n">reject_epoch</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reject_artf</span><span class="o">=</span><span class="n">reject_types</span><span class="p">)</span>
                    <span class="n">segments</span><span class="o">.</span><span class="n">read_data</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ref_chan</span><span class="p">,</span> <span class="n">grp_name</span><span class="o">=</span><span class="n">grp_name</span><span class="p">)</span>

                    
                    <span class="c1"># Process each detection method</span>
                    <span class="n">channel_spindles</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">channel_json_spindles</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="c1">## Loop through methods (i.e. WHALE IT!)</span>
                    <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">meth</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applying method: </span><span class="si">{</span><span class="n">meth</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="c1">### define detection</span>
                        <span class="n">detection</span> <span class="o">=</span> <span class="n">DetectSpindle</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="n">frequency</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">,</span> 
                        <span class="o">**</span><span class="n">detector_params</span><span class="p">)</span>
                        
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detector parameters for </span><span class="si">{</span><span class="n">meth</span><span class="si">}</span><span class="s2">: frequency=</span><span class="si">{</span><span class="n">frequency</span><span class="si">}</span><span class="s2">, duration=</span><span class="si">{</span><span class="n">duration</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">detection</span><span class="p">,</span> <span class="s1">&#39;det_thresh&#39;</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  det_thresh: </span><span class="si">{</span><span class="n">detection</span><span class="o">.</span><span class="n">det_thresh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">detection</span><span class="p">,</span> <span class="s1">&#39;sel_thresh&#39;</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  sel_thresh: </span><span class="si">{</span><span class="n">detection</span><span class="o">.</span><span class="n">sel_thresh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Detecting events, segment </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                            <span class="c1"># Apply polarity adjustment if needed</span>
                            <span class="k">if</span> <span class="n">polar</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
                                <span class="k">pass</span> <span class="c1"># No change needed</span>
                            <span class="k">elif</span> <span class="n">polar</span> <span class="o">==</span> <span class="s1">&#39;opposite&#39;</span><span class="p">:</span>
                                <span class="n">seg</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*-</span><span class="mi">1</span>
                            <span class="c1"># Run detection</span>
                            <span class="n">spindles</span> <span class="o">=</span> <span class="n">detection</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>

                            <span class="k">if</span> <span class="n">spindles</span> <span class="ow">and</span> <span class="n">save_to_annotations</span> <span class="ow">and</span> <span class="n">new_annotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">spindles</span><span class="o">.</span><span class="n">to_annot</span><span class="p">(</span><span class="n">new_annotations</span><span class="p">,</span> <span class="s1">&#39;spindle&#39;</span><span class="p">)</span>
                            
                            <span class="c1"># Add to our results</span>
                            <span class="c1"># Convert to dictionary format for consistency</span>
                            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spindles</span><span class="p">:</span>
                                <span class="c1"># Add UUID to each spindle</span>
                                <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
                                <span class="c1"># Add channel information</span>
                                <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;chan&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span>
                                <span class="n">channel_spindles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
                                
                                <span class="c1"># Add to JSON </span>
                                <span class="k">if</span> <span class="n">json_dir</span><span class="p">:</span>
                                    <span class="c1"># Extract key properties in a serializable format</span>
                                    <span class="n">sp_data</span> <span class="o">=</span> <span class="p">{</span>
                                        <span class="s1">&#39;uuid&#39;</span><span class="p">:</span> <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span>
                                        <span class="s1">&#39;chan&#39;</span><span class="p">:</span> <span class="n">ch</span><span class="p">,</span>
                                        <span class="s1">&#39;start_time&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
                                        <span class="s1">&#39;end_time&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
                                    <span class="c1">#    &#39;peak_time&#39;: float(sp.get(&#39;peak_time&#39;, 0)),</span>
                                    <span class="c1">#    &#39;duration&#39;: float(sp.get(&#39;dur&#39;, 0)),</span>
                                    <span class="c1">#    &#39;ptp_det&#39;: float(sp.get(&#39;ptp_det&#39;, 0)),</span>
                                        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">meth</span>
                                    <span class="p">}</span>
                                    
                                    <span class="n">sp_data</span><span class="p">[</span><span class="s1">&#39;stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stage</span>
                                    <span class="n">sp_data</span><span class="p">[</span><span class="s1">&#39;freq_range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">frequency</span>
                                    <span class="c1"># Add frequency/power/amplitude if available</span>
                                    <span class="c1">#if &#39;peak_freq&#39; in sp:</span>
                                    <span class="c1">#    sp_data[&#39;peak_freq&#39;] = float(sp[&#39;peak_freq&#39;])</span>
                                    <span class="c1">#if &#39;peak_val&#39; in sp:</span>
                                    <span class="c1">#    sp_data[&#39;peak_val&#39;] = float(sp[&#39;peak_val&#39;])</span>
                                    <span class="c1">#if &#39;power&#39; in sp:</span>
                                    <span class="c1">#    sp_data[&#39;power&#39;] = float(sp[&#39;power&#39;])</span>
                                        
                                    <span class="n">channel_json_spindles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_data</span><span class="p">)</span>
                    <span class="n">all_spindles</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">channel_spindles</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">channel_spindles</span><span class="p">)</span><span class="si">}</span><span class="s2"> spindles in channel </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">stages_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">json_dir</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">ch_json_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">json_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;spindles_</span><span class="si">{</span><span class="n">method_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">freq_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">stages_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2">.json&quot;</span><span class="p">)</span>

                            <span class="c1"># Create empty JSON if no spindles found but flag is set</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">channel_json_spindles</span> <span class="ow">and</span> <span class="n">create_empty_json</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating empty JSON file for channel </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2"> (no spindles detected)&quot;</span><span class="p">)</span>
                                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">ch_json_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                                    <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">([],</span> <span class="n">f</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">channel_json_spindles</span><span class="p">:</span>
                                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">ch_json_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                                    <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">channel_json_spindles</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved spindle data for channel </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">ch_json_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error saving channel JSON: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>        
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: No spin channel </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                        
                        <span class="c1"># Create empty JSON file even in case of error</span>
                        <span class="k">if</span> <span class="n">json_dir</span> <span class="ow">and</span> <span class="n">create_empty_json</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">stages_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span> <span class="k">if</span> <span class="n">stage</span> <span class="k">else</span> <span class="s2">&quot;all&quot;</span>
                                <span class="n">ch_json_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">json_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;spindles_</span><span class="si">{</span><span class="n">method_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">freq_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">stages_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2">.json&quot;</span><span class="p">)</span>
                                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">ch_json_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                                    <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">([],</span> <span class="n">f</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created empty JSON file for channel </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2"> after error&quot;</span><span class="p">)</span>
                            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">json_e</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating empty JSON for channel </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">json_e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Save the new annotation file if needed</span>
        <span class="k">if</span> <span class="n">save_to_annotations</span> <span class="ow">and</span> <span class="n">new_annotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">all_spindles</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_annotations</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">annotation_file_path</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_spindles</span><span class="p">)</span><span class="si">}</span><span class="s2"> spindles to new annotation file: </span><span class="si">{</span><span class="n">annotation_file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error saving annotation file: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



        <span class="c1"># Return all detected spindles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total spindles detected across all channels: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_spindles</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_spindles</span></div>

    
 

<div class="viewcode-block" id="ParalEvents.export_spindle_parameters_to_csv">
<a class="viewcode-back" href="../../turtlewave_hdEEG.html#turtlewave_hdEEG.eventprocessor.ParalEvents.export_spindle_parameters_to_csv">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">export_spindle_parameters_to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_input</span><span class="p">,</span> <span class="n">csv_file</span><span class="p">,</span> <span class="n">export_params</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> 
                              <span class="n">frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ref_chan</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grp_name</span><span class="o">=</span><span class="s1">&#39;eeg&#39;</span><span class="p">,</span> <span class="n">n_fft_sec</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> 
                              <span class="n">file_pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">skip_empty_files</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    </span>
<span class="sd">        Calculate spindle parameters from JSON files and export to CSV.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json_input : str or list</span>
<span class="sd">            Path to JSON file, directory of JSON files, or list of JSON files</span>
<span class="sd">        csv_file : str</span>
<span class="sd">            Path to output CSV file</span>
<span class="sd">        export_params : dict or str</span>
<span class="sd">            Parameters to export. If &#39;all&#39;, exports all available parameters</span>
<span class="sd">        frequency : tuple or None</span>
<span class="sd">            Frequency range for power calculations (default: None, uses original range from JSON)</span>
<span class="sd">        ref_chan : list or None</span>
<span class="sd">            Reference channel(s) to use for parameter calculation</span>
<span class="sd">        n_fft_sec : int</span>
<span class="sd">            FFT window size in seconds for spectral analysis</span>
<span class="sd">        file_pattern : str or None</span>
<span class="sd">            Pattern to filter JSON files if json_input is a directory</span>
<span class="sd">        grp_name : str</span>
<span class="sd">            Group name for channel selection</span>
<span class="sd">        skip_empty_files : bool</span>
<span class="sd">            Whether to skip empty JSON files or include them in the report</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary of calculated parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#self.logger.warning(&quot;export_spindle_parameters_to_csv is deprecated. Please use calculate_and_store_parameters() and export_parameters_to_csv() instead.&quot;)</span>
        
        <span class="c1"># Call the new methods as a migration path</span>
        <span class="c1">#db_path = os.path.join(os.path.dirname(csv_file), &quot;spindle_parameters.db&quot;)</span>
        <span class="c1">#self.calculate_and_store_parameters(json_input, db_path, export_params, frequency, n_fft_sec=n_fft_sec, file_pattern=file_pattern)</span>
        <span class="c1">#self.export_parameters_to_csv(db_path, csv_file)</span>
        
        <span class="c1">#return None  # Original returned a dict of parameters</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">wonambi.trans.analyze</span><span class="w"> </span><span class="kn">import</span> <span class="n">event_params</span><span class="p">,</span> <span class="n">export_event_params</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clean_memory</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating spindle parameters for CSV export...&quot;</span><span class="p">)</span>
         
        <span class="c1"># Load spindles from JSON file(s)</span>
        <span class="n">json_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">file_pattern</span><span class="p">:</span>
            <span class="c1"># Get all JSON files in the directory</span>
            <span class="n">all_json_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">json_input</span><span class="p">,</span> <span class="s2">&quot;*.json&quot;</span><span class="p">))</span>
            <span class="c1"># Match files where pattern is followed by underscore or dot</span>
            <span class="n">json_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">all_json_files</span> <span class="k">if</span> 
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">_&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">or</span> 
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">.&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If no pattern, get all JSON files</span>
            <span class="n">json_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">json_input</span><span class="p">,</span> <span class="s2">&quot;*.json&quot;</span><span class="p">))</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">json_files</span><span class="p">)</span><span class="si">}</span><span class="s2"> JSON files matching pattern: </span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">json_files</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No JSON files found matching pattern: </span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
                <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;No JSON files found matching pattern:&quot;</span><span class="p">,</span> <span class="n">file_pattern</span><span class="p">])</span>
            <span class="k">return</span> <span class="kc">None</span>


        <span class="c1"># Load spindles from JSON files</span>
        <span class="n">all_spindles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">empty_channels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">json_files</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">spindles</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spindles</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spindles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">all_spindles</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">spindles</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Extract channel name from filename</span>
                        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
                        <span class="n">parts</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">chan</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.json&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                            <span class="n">empty_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> contains an empty list (no spindles)&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Unexpected format in </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spindles</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">spindles</span><span class="p">,</span><span class="w"> </span><span class="nb">list</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">0</span><span class="si">}</span><span class="s2"> spindles from </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_spindles</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No spindles found in the input files&quot;</span><span class="p">)</span>
            <span class="c1"># Create an empty CSV file with header to indicate processing was done</span>
            <span class="k">if</span> <span class="n">empty_channels</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">skip_empty_files</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
                        <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
                        <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;No spindles were detected in the following channels:&quot;</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">empty_channels</span><span class="p">:</span>
                            <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">chan</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created empty CSV file at </span><span class="si">{</span><span class="n">csv_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating empty CSV: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        
        <span class="c1"># Get frequency band from spindles if not provided</span>
        <span class="k">if</span> <span class="n">frequency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try to extract from the first spindle</span>
                <span class="k">if</span> <span class="s1">&#39;freq_range&#39;</span> <span class="ow">in</span> <span class="n">all_spindles</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">freq_range</span> <span class="o">=</span> <span class="n">all_spindles</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;freq_range&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq_range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">frequency</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">freq_range</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_range</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">freq_range</span><span class="p">:</span>
                        <span class="n">freq_parts</span> <span class="o">=</span> <span class="n">freq_range</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
                        <span class="n">frequency</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">freq_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()),</span> 
                                    <span class="nb">float</span><span class="p">(</span><span class="n">freq_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using frequency range from JSON: </span><span class="si">{</span><span class="n">frequency</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># Default if we can&#39;t extract</span>
                <span class="n">frequency</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using default frequency range: </span><span class="si">{</span><span class="n">frequency</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        

        <span class="c1"># Get sampling frequency from dataset</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">s_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;s_freq&#39;</span><span class="p">]</span>
            <span class="c1">#print(f&quot;Dataset sampling frequency: {s_freq} Hz&quot;)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Could not determine dataset sampling frequency&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="c1"># Try to get recording start time if not provided</span>
        <span class="n">recording_start_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Get it from dataset header</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="s1">&#39;header&#39;</span><span class="p">):</span>
                <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">header</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="s1">&#39;start_time&#39;</span><span class="p">):</span>
                    <span class="n">recording_start_time</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">start_time</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;start_time&#39;</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
                    <span class="n">recording_start_time</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span>
                    
            <span class="k">if</span> <span class="n">recording_start_time</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found recording start time: </span><span class="si">{</span><span class="n">recording_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Warning: Could not find recording start time in dataset header. Using relative time only.&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error getting recording start time: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Warning:Using relative time only.&quot;</span><span class="p">)</span>

        
        <span class="c1"># Group spindles by channel for more efficient processing</span>
        <span class="n">spindles_by_chan</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">all_spindles</span><span class="p">:</span>
            <span class="n">chan</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;chan&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chan</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spindles_by_chan</span><span class="p">:</span>
                <span class="n">spindles_by_chan</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">spindles_by_chan</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grouped spindles by </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spindles_by_chan</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels&quot;</span><span class="p">)</span>

        <span class="c1"># Process each channel</span>
        <span class="n">all_segments</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Load data for each channel and create segments</span>
        <span class="k">for</span> <span class="n">chan</span><span class="p">,</span> <span class="n">spindles</span> <span class="ow">in</span> <span class="n">spindles_by_chan</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spindles</span><span class="p">)</span><span class="si">}</span><span class="s2"> spindles for channel </span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Use fetch for proper segmentation - critical fix</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Create a list of time windows for spindles</span>
                <span class="n">spindle_windows</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spindles</span><span class="p">:</span>
                    <span class="n">start_time</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span>
                    <span class="n">end_time</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;end_time&#39;</span><span class="p">]</span>
                    <span class="n">spindle_windows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">))</span>
                

                <span class="c1"># Use direct segment creation for better power calculation</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spindle_windows</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Add a small buffer for FFT calculation</span>
                        <span class="n">buffer</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># 100ms buffer</span>
                        <span class="n">start_with_buffer</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_time</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">)</span>
                        <span class="n">end_with_buffer</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">+</span> <span class="n">buffer</span>
                        
                        <span class="c1"># Read data for this specific spindle</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">read_data</span><span class="p">(</span><span class="n">chan</span><span class="o">=</span><span class="p">[</span><span class="n">chan</span><span class="p">],</span> 
                                                    <span class="n">begtime</span><span class="o">=</span><span class="n">start_with_buffer</span><span class="p">,</span> 
                                                    <span class="n">endtime</span><span class="o">=</span><span class="n">end_with_buffer</span><span class="p">)</span>
                        <span class="c1"># Create a segment for this spindle</span>
                        <span class="n">seg</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span>
                            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;spindle&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;start&#39;</span><span class="p">:</span> <span class="n">start_time</span><span class="p">,</span>
                            <span class="s1">&#39;end&#39;</span><span class="p">:</span> <span class="n">end_time</span><span class="p">,</span>
                            <span class="s1">&#39;n_stitch&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="s1">&#39;stage&#39;</span><span class="p">:</span> <span class="n">spindles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stage&#39;</span><span class="p">),</span>
                            <span class="s1">&#39;cycle&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="s1">&#39;chan&#39;</span><span class="p">:</span> <span class="n">chan</span><span class="p">,</span>  <span class="c1"># Important: store the channel</span>
                            <span class="s1">&#39;uuid&#39;</span><span class="p">:</span> <span class="n">spindles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;uuid&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>  <span class="c1"># Store ID for tracking</span>
                        <span class="p">}</span>
                        <span class="n">all_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>

                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating segment for spindle </span><span class="si">{</span><span class="n">start_time</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">end_time</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing channel </span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_segments</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No valid segments created for parameter calculation&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_segments</span><span class="p">)</span><span class="si">}</span><span class="s2"> segments for parameter calculation&quot;</span><span class="p">)</span>
        
        <span class="c1"># Calculate parameters</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">all_segments</span> <span class="ow">and</span> <span class="n">n_fft_sec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_fft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft_sec</span> <span class="o">*</span> <span class="n">s_freq</span><span class="p">)</span>                
        
        <span class="c1"># Create a temporary file to use for the initial export</span>
        <span class="n">temp_csv</span> <span class="o">=</span> <span class="n">csv_file</span> <span class="o">+</span> <span class="s1">&#39;.temp&#39;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Calculate parameters with proper FFT settings</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating parameters with frequency band </span><span class="si">{</span><span class="n">frequency</span><span class="si">}</span><span class="s2"> and n_fft=</span><span class="si">{</span><span class="n">n_fft</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">event_params</span><span class="p">(</span><span class="n">all_segments</span><span class="p">,</span> <span class="n">export_params</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="n">frequency</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span> <span class="c1"># can include &#39;slope&#39; in event_params </span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No parameters calculated&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            
            <span class="c1"># Export parameters to temporary CSV file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exporting parameters to temporary file&quot;</span><span class="p">)</span>            
            <span class="n">export_event_params</span><span class="p">(</span><span class="n">temp_csv</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Store UUIDs for later use (they&#39;re not included in the params for CSV export)</span>
            <span class="n">uuid_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_segments</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;uuid&#39;</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">:</span>
                    <span class="n">uuid_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">segment</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">]</span>

            <span class="c1"># Now read the temporary CSV and process it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing CSV to remove summary rows and add HH:MM:SS format&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">temp_csv</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infile</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
                <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>
                <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>

                <span class="c1"># Read all rows</span>
                <span class="n">all_rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>

                <span class="c1"># Find the header row (the one with &#39;Start time&#39;)</span>
                <span class="n">header_row_index</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">start_time_index</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_rows</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">row</span> <span class="ow">and</span> <span class="s1">&#39;Start time&#39;</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
                        <span class="n">header_row_index</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">start_time_index</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;Start time&#39;</span><span class="p">)</span>
                        <span class="k">break</span>
                
                <span class="k">if</span> <span class="n">header_row_index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">start_time_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Error: Could not find &#39;Start time&#39; column in CSV&quot;</span><span class="p">)</span>
                    <span class="c1"># Copy the original file as fallback</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">temp_csv</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
                        <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
                    <span class="k">return</span> <span class="n">params</span>
            
                <span class="c1"># Create filtered rows without Mean, SD, Mean of ln, SD of ln</span>
                <span class="n">filtered_rows</span> <span class="o">=</span> <span class="p">[]</span>
            
                <span class="c1"># Add any prefix rows before the header (like &#39;Wonambi v7.15&#39;)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">header_row_index</span><span class="p">):</span>
                    <span class="n">filtered_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_rows</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># Add the header row and add &#39;Start time (HH:MM:SS)&#39; and &#39;UUID&#39; columns</span>
                <span class="n">header_row</span> <span class="o">=</span> <span class="n">all_rows</span><span class="p">[</span><span class="n">header_row_index</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># Add &#39;Start time (HH:MM:SS)&#39; right after &#39;Start time&#39;</span>
                <span class="n">header_row</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">start_time_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Start time (HH:MM:SS)&#39;</span><span class="p">)</span>

                <span class="c1"># Add UUID column if not already present</span>
                <span class="k">if</span> <span class="s1">&#39;UUID&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">header_row</span><span class="p">:</span>
                    <span class="n">header_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;UUID&#39;</span><span class="p">)</span>
                <span class="n">filtered_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">header_row</span><span class="p">)</span>

                <span class="c1"># Skip the header row and the 4 statistic rows (Mean, SD, Mean of ln, SD of ln)</span>
                <span class="c1"># and add the rest of the data rows</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">header_row_index</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_rows</span><span class="p">)):</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">all_rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">:</span>  <span class="c1"># Skip empty rows</span>
                        <span class="k">continue</span>
                        
                    <span class="c1"># Make a copy of the row to modify</span>
                    <span class="n">new_row</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    
                    <span class="c1"># Add the HH:MM:SS time format after the start time</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">start_time_index</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">start_time_sec</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">start_time_index</span><span class="p">])</span>
                            
                            <span class="c1"># Convert to HH:MM:SS</span>
                            <span class="k">def</span><span class="w"> </span><span class="nf">sec_to_time</span><span class="p">(</span><span class="n">seconds</span><span class="p">):</span>
                                <span class="n">hours</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">seconds</span> <span class="o">//</span> <span class="mi">3600</span><span class="p">)</span>
                                <span class="n">minutes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">seconds</span> <span class="o">%</span> <span class="mi">3600</span><span class="p">)</span> <span class="o">//</span> <span class="mi">60</span><span class="p">)</span>
                                <span class="n">sec</span> <span class="o">=</span> <span class="n">seconds</span> <span class="o">%</span> <span class="mi">60</span>
                                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hours</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">minutes</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">sec</span><span class="si">:</span><span class="s2">06.3f</span><span class="si">}</span><span class="s2">&quot;</span>
                                
                            <span class="c1"># Calculate clock time if recording start time is available</span>
                            <span class="k">if</span> <span class="n">recording_start_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">delta</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">start_time_sec</span><span class="p">)</span>
                                    <span class="n">event_time</span> <span class="o">=</span> <span class="n">recording_start_time</span> <span class="o">+</span> <span class="n">delta</span>
                                    <span class="n">start_time_hms</span> <span class="o">=</span> <span class="n">event_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%H:%M:%S.</span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="n">start_time_hms</span> <span class="o">=</span> <span class="n">sec_to_time</span><span class="p">(</span><span class="n">start_time_sec</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">start_time_hms</span> <span class="o">=</span> <span class="n">sec_to_time</span><span class="p">(</span><span class="n">start_time_sec</span><span class="p">)</span>
                            
                            <span class="c1"># Insert the HH:MM:SS time</span>
                            <span class="n">new_row</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">start_time_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start_time_hms</span><span class="p">)</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                            <span class="c1"># If we can&#39;t convert, insert empty cell</span>
                            <span class="n">new_row</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">start_time_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Row is too short, insert empty cell</span>
                        <span class="n">new_row</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">start_time_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                    
                    <span class="c1"># Add UUID at the end </span>
                    <span class="c1"># Calculate the segment index</span>
                    <span class="n">segment_index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">header_row_index</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">segment_index</span> <span class="ow">in</span> <span class="n">uuid_dict</span><span class="p">:</span>
                        <span class="n">new_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uuid_dict</span><span class="p">[</span><span class="n">segment_index</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    
                    <span class="n">filtered_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_row</span><span class="p">)</span>
                
                <span class="c1"># Write all filtered rows</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">filtered_rows</span><span class="p">:</span>
                    <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                   <span class="c1"># Remove the temporary file</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_csv</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Note: Could not remove temporary file </span><span class="si">{</span><span class="n">temp_csv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully exported to </span><span class="si">{</span><span class="n">csv_file</span><span class="si">}</span><span class="s2"> with HH:MM:SS time format&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">params</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error calculating parameters: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">traceback</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">None</span></div>


    
<div class="viewcode-block" id="ParalEvents.export_spindle_density_to_csv">
<a class="viewcode-back" href="../../turtlewave_hdEEG.html#turtlewave_hdEEG.eventprocessor.ParalEvents.export_spindle_density_to_csv">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">export_spindle_density_to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_input</span><span class="p">,</span> <span class="n">csv_file</span><span class="p">,</span> <span class="n">stage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export spindle statistics to CSV with both whole night and stage-specific densities.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json_input : str or list</span>
<span class="sd">            Path to JSON file, directory of JSON files, or list of JSON files</span>
<span class="sd">        csv_file : str</span>
<span class="sd">            Path to output CSV file</span>
<span class="sd">        stage : str or list</span>
<span class="sd">            Sleep stage(s) to include (e.g., &#39;NREM2&#39;, [&#39;NREM2&#39;, &#39;NREM3&#39;])</span>
<span class="sd">            if None, will extract stages from spindles</span>
<span class="sd">        file_pattern : str or None</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with spindle statistics by channel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">csv</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
        
        <span class="c1"># Load spindles from JSON file(s)</span>
        <span class="n">json_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">file_pattern</span><span class="p">:</span>
            <span class="c1"># Get all JSON files in the directory</span>
            <span class="n">all_json_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">json_input</span><span class="p">,</span> <span class="s2">&quot;*.json&quot;</span><span class="p">))</span>
            <span class="c1"># Match files where pattern is followed by underscore or dot</span>
            <span class="n">json_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">all_json_files</span> <span class="k">if</span> 
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">_&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">or</span> 
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">.&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If no pattern, get all JSON files</span>
            <span class="n">json_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">json_input</span><span class="p">,</span> <span class="s2">&quot;*.json&quot;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">json_files</span><span class="p">)</span><span class="si">}</span><span class="s2"> JSON files matching pattern: </span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">json_files</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No JSON files found matching pattern: </span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Create an empty CSV file with a message</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
                    <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
                    <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s2">&quot;No JSON files found matching pattern:&quot;</span><span class="p">,</span> <span class="n">file_pattern</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created empty CSV file at </span><span class="si">{</span><span class="n">csv_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating empty CSV: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="k">return</span> <span class="kc">None</span>



        <span class="c1"># Prepare the stages as a list</span>
        <span class="k">if</span> <span class="n">stage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">combined_stages</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">stage_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">combined_stages</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">stage_list</span> <span class="o">=</span> <span class="n">stage</span>
            <span class="n">combined_stage_name</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stage_list</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating combined spindle density for stages: </span><span class="si">{</span><span class="n">combined_stage_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">combined_stages</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">stage_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating spindle density for stage: </span><span class="si">{</span><span class="n">stage_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">combined_stages</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">stage_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating spindle density for stage: </span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        

        <span class="n">all_spindles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">json_files</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">spindles</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="n">all_spindles</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">spindles</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spindles</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[])</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Get stage durations from annotations (assuming annotations are available)</span>
        <span class="n">epoch_duration_sec</span> <span class="o">=</span> <span class="mi">30</span>  <span class="c1"># Standard epoch duration</span>
        
        <span class="c1"># Count epochs for each stage</span>
        <span class="n">stage_counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">all_stages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">get_stages</span><span class="p">()</span>

                                
        <span class="c1"># Count epochs for each stage</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">all_stages</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Wake&#39;</span><span class="p">,</span> <span class="s1">&#39;NREM1&#39;</span><span class="p">,</span> <span class="s1">&#39;NREM2&#39;</span><span class="p">,</span> <span class="s1">&#39;NREM3&#39;</span><span class="p">,</span> <span class="s1">&#39;REM&#39;</span><span class="p">]:</span>
                <span class="n">stage_counts</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>


        <span class="c1"># Calculate durations in minutes</span>
        <span class="n">stage_durations</span> <span class="o">=</span> <span class="p">{</span><span class="n">stg</span><span class="p">:</span> <span class="n">count</span> <span class="o">*</span> <span class="n">epoch_duration_sec</span> <span class="o">/</span> <span class="mi">60</span> <span class="k">for</span> <span class="n">stg</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">stage_counts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
         
        <span class="n">total_duration_min</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">stage_durations</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    
        <span class="c1"># Extract stages from spindles if stage is None</span>
        <span class="n">spindle_stages</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">all_spindles</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;stage&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
                <span class="k">continue</span>        
            <span class="n">sp_stage</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;stage&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sp_stage</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sp_stage</span><span class="p">:</span>
                    <span class="n">spindle_stages</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spindle_stages</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sp_stage</span><span class="p">))</span>
        
        <span class="c1"># If stage is None, process all stages found in spindles</span>
        <span class="k">if</span> <span class="n">stage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stages_to_process</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">spindle_stages</span><span class="p">)</span>
            <span class="n">combined_stages</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">combined_stages</span><span class="p">:</span>
            <span class="c1"># Just process the combined stage set</span>
            <span class="n">stages_to_process</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage_list</span><span class="p">]</span>  <span class="c1"># List containing the list of stages</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Process individual stages</span>
            <span class="n">stages_to_process</span> <span class="o">=</span> <span class="n">stage_list</span>

        <span class="c1"># Group spindles by channel and stage</span>
        <span class="n">spindles_by_chan_stage</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
        <span class="n">spindles_by_chan</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">all_spindles</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># Get channel information</span>
            <span class="n">chan</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s1">&#39;chan&#39;</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
                <span class="n">chan</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;chan&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="s1">&#39;channel&#39;</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
                <span class="n">chan</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">chan</span><span class="p">:</span>
                <span class="k">continue</span>
        
            
            <span class="c1"># Add to whole night spindle count</span>
            <span class="n">spindles_by_chan</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">combined_stages</span><span class="p">:</span>
                <span class="c1"># Process stage info, handling multiple stages per spindle</span>
                <span class="k">if</span> <span class="s1">&#39;stage&#39;</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
                    <span class="n">sp_stages</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;stage&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="s1">&#39;stage&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="s1">&#39;stage&#39;</span><span class="p">]]</span>
            
                <span class="k">for</span> <span class="n">sp_stage</span> <span class="ow">in</span> <span class="n">sp_stages</span><span class="p">:</span>
                    <span class="n">sp_stage</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sp_stage</span><span class="p">)</span>  <span class="c1"># Convert to string for consistency</span>
                    <span class="c1"># Add to stage-specific spindle count</span>
                    <span class="n">spindles_by_chan_stage</span><span class="p">[</span><span class="n">chan</span><span class="p">][</span><span class="n">sp_stage</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
                

        <span class="c1"># Calculate statistics by channel for each stage</span>
        <span class="n">stage_channel_stats</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">spindles_by_chan</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="c1"># Whole night statistics</span>
            <span class="n">all_chan_spindles</span> <span class="o">=</span> <span class="n">spindles_by_chan</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span>
        
            
            <span class="k">for</span> <span class="n">process_stage</span> <span class="ow">in</span> <span class="n">stages_to_process</span><span class="p">:</span>
                <span class="c1"># Get spindles for this channel and stage</span>
                <span class="n">stage_spindles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">combined_stages</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">process_stage</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">process_stage</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">stages_to_include</span> <span class="o">=</span> <span class="n">process_stage</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process_stage</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">stage_list</span>
                    <span class="n">stage_name_display</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stages_to_include</span><span class="p">)</span>
                    <span class="c1"># Create a set of stages to check against</span>
                    <span class="n">stages_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stages_to_include</span><span class="p">)</span>
                    <span class="c1"># Find spindles that belong to ANY of the target stages, but count each spindle only once</span>
                    <span class="n">stage_spindles</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">seen_spindles</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Track spindles we&#39;ve already counted</span>

                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">all_chan_spindles</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s1">&#39;stage&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="c1"># Get spindle&#39;s stages as a set</span>
                        <span class="n">sp_stages</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;stage&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="s1">&#39;stage&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="s1">&#39;stage&#39;</span><span class="p">]]</span>
                        <span class="n">sp_stages</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sp_stages</span><span class="p">)</span>

                        <span class="c1"># Check if any of the spindle&#39;s stages match any target stage</span>
                        <span class="k">if</span> <span class="n">sp_stages</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">stages_set</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen_spindles</span><span class="p">:</span>
                            <span class="n">stage_spindles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
                            <span class="n">seen_spindles</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>

                    <span class="c1"># Sum durations for all specified stages</span>
                    <span class="n">stage_duration_min</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">stage_durations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stages_to_include</span><span class="p">)</span>
        
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Single stage processing</span>
                    <span class="n">s_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">process_stage</span><span class="p">)</span>
                    <span class="n">stage_spindles</span> <span class="o">=</span> <span class="n">spindles_by_chan_stage</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s_str</span><span class="p">,</span> <span class="p">[])</span>
                    <span class="n">stage_name_display</span> <span class="o">=</span> <span class="n">process_stage</span>
                    <span class="n">stage_duration_min</span> <span class="o">=</span> <span class="n">stage_durations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s_str</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            
                <span class="c1"># Skip if no spindles for this stage and channel</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stage_spindles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
            
                <span class="c1"># Count spindles</span>
                <span class="n">stage_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stage_spindles</span><span class="p">)</span>
                <span class="n">whole_night_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_chan_spindles</span><span class="p">)</span>
                
                <span class="c1"># Calculate density (spindles per minute)</span>
                <span class="n">stage_density</span> <span class="o">=</span> <span class="n">stage_count</span> <span class="o">/</span> <span class="n">stage_duration_min</span> <span class="k">if</span> <span class="n">stage_duration_min</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">whole_night_density</span> <span class="o">=</span> <span class="n">whole_night_count</span> <span class="o">/</span> <span class="n">total_duration_min</span> <span class="k">if</span> <span class="n">total_duration_min</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                
                <span class="c1"># Calculate mean duration of spindles</span>
                <span class="n">durations</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">stage_spindles</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;start_time&#39;</span> <span class="ow">in</span> <span class="n">sp</span> <span class="ow">and</span> <span class="s1">&#39;end_time&#39;</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
                        <span class="n">durations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="s1">&#39;end_time&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">])</span>
                
                <span class="n">mean_duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span> <span class="k">if</span> <span class="n">durations</span> <span class="k">else</span> <span class="mi">0</span>
                
                <span class="c1"># Store the statistics</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">process_stage</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process_stage</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">process_stage</span>
                <span class="n">stage_channel_stats</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="n">stage_count</span><span class="p">,</span>
                    <span class="s1">&#39;stage_density&#39;</span><span class="p">:</span> <span class="n">stage_density</span><span class="p">,</span>
                    <span class="s1">&#39;whole_night_density&#39;</span><span class="p">:</span> <span class="n">whole_night_density</span><span class="p">,</span>
                    <span class="s1">&#39;mean_duration&#39;</span><span class="p">:</span> <span class="n">mean_duration</span><span class="p">,</span>
                    <span class="s1">&#39;stage_name_display&#39;</span><span class="p">:</span> <span class="n">stage_name_display</span><span class="p">,</span>
                    <span class="s1">&#39;stage_duration_min&#39;</span><span class="p">:</span> <span class="n">stage_duration_min</span><span class="p">,</span>
                <span class="p">}</span>
        
        <span class="c1"># Export to CSV - each stage gets its own section</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            
            <span class="c1"># Add whole night summary</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;Whole Night Summary&#39;</span><span class="p">])</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;Total Recording Duration (min)&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">total_duration_min</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">])</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([])</span>
            
            <span class="c1"># Add stage duration summary</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;Stage Duration Summary&#39;</span><span class="p">])</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;Stage&#39;</span><span class="p">,</span> <span class="s1">&#39;Duration (min)&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">stg</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">stage_durations</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">stg</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stage_durations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">stg</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
            <span class="c1"># If combined stages were requested, add their summary too</span>
            <span class="k">if</span> <span class="n">combined_stages</span><span class="p">:</span>
                <span class="n">combined_duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">stage_durations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stage_list</span><span class="p">)</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">combined_stage_name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">combined_duration</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>

            <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([])</span>
            
            <span class="c1"># Process each stage</span>
            <span class="k">for</span> <span class="n">process_stage</span> <span class="ow">in</span> <span class="n">stages_to_process</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">process_stage</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process_stage</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">process_stage</span>
                <span class="c1"># Skip if no data for this stage</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stage_channel_stats</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># Get any channel&#39;s stats to extract the stage name display</span>
                <span class="n">any_chan</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">stage_channel_stats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="n">stage_name_display</span> <span class="o">=</span> <span class="n">stage_channel_stats</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">any_chan</span><span class="p">][</span><span class="s1">&#39;stage_name_display&#39;</span><span class="p">]</span>

                <span class="c1"># Add stage header</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;Sleep Stage: </span><span class="si">{</span><span class="n">stage_name_display</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span>
                    <span class="s1">&#39;Channel&#39;</span><span class="p">,</span> 
                    <span class="s1">&#39;Count&#39;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s1">&#39;Density in </span><span class="si">{</span><span class="n">stage_name_display</span><span class="si">}</span><span class="s1"> (events/min)&#39;</span><span class="p">,</span> 
                    <span class="s1">&#39;Whole Night Density (events/min)&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Mean Duration (s)&#39;</span>
                <span class="p">])</span>

                
                <span class="c1"># Write channel-specific statistics, sorted by channel name</span>
                <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">stage_channel_stats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">stats</span> <span class="o">=</span> <span class="n">stage_channel_stats</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">chan</span><span class="p">]</span>
                    <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span>
                        <span class="n">chan</span><span class="p">,</span> 
                        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">],</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;stage_density&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whole_night_density&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean_duration&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">])</span>
                
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exported spindle statistics to </span><span class="si">{</span><span class="n">csv_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">stage_channel_stats</span><span class="p">)</span></div>

            

<div class="viewcode-block" id="ParalEvents.save_detection_summary">
<a class="viewcode-back" href="../../turtlewave_hdEEG.html#turtlewave_hdEEG.eventprocessor.ParalEvents.save_detection_summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_detection_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">results_summary</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a comprehensive summary of detection parameters and results.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_dir : str</span>
<span class="sd">            Directory to save the summary</span>
<span class="sd">        method : str</span>
<span class="sd">            Detection method used</span>
<span class="sd">        parameters : dict</span>
<span class="sd">            All parameters used for detection</span>
<span class="sd">        results_summary : dict</span>
<span class="sd">            Summary of detection results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">_%H%M%S&#39;</span><span class="p">)</span>
            <span class="n">summary_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;detection_summary_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">timestamp</span><span class="si">}</span><span class="s2">.json&quot;</span><span class="p">)</span>
            
            <span class="n">summary_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;detection_method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
                <span class="s1">&#39;parameters&#39;</span><span class="p">:</span> <span class="n">parameters</span><span class="p">,</span>
                <span class="s1">&#39;results&#39;</span><span class="p">:</span> <span class="n">results_summary</span><span class="p">,</span>
                <span class="s1">&#39;timestamp&#39;</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span>
                <span class="s1">&#39;software_version&#39;</span><span class="p">:</span> <span class="s1">&#39;TurtleWave hdEEG GUI&#39;</span>
            <span class="p">}</span>
            
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">summary_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">summary_data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved detection summary to: </span><span class="si">{</span><span class="n">summary_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">summary_file</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error saving detection summary: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="ParalEvents.initialize_sqlite_database">
<a class="viewcode-back" href="../../turtlewave_hdEEG.html#turtlewave_hdEEG.eventprocessor.ParalEvents.initialize_sqlite_database">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_sqlite_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="s1">&#39;neural_events.db&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create SQLite database optimized for storing calculated event parameters </span>
<span class="sd">        from event_params() function.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        db_path : str</span>
<span class="sd">            Path to SQLite database file</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Path to created database</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

        <span class="c1"># If db_path is a directory, append the default filename</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">db_path</span><span class="p">):</span>
            <span class="n">db_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="s1">&#39;neural_events.db&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Database path was a directory, using: </span><span class="si">{</span><span class="n">db_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Create directory for database if it doesn&#39;t exist</span>
        <span class="n">db_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">db_dir</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">db_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">db_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created directory for database: </span><span class="si">{</span><span class="n">db_dir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Check if database exists</span>
        <span class="n">db_exists</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
        
        <span class="c1"># Define the database initialization operation</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">init_db</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
            <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
            <span class="c1"># Main events table with common fields across all event types</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            CREATE TABLE IF NOT EXISTS events (</span>
<span class="s1">                uuid TEXT PRIMARY KEY,</span>
<span class="s1">                event_type TEXT,           -- &#39;spindle&#39;, &#39;slow_wave&#39;, &#39;ripple&#39;, etc.</span>
<span class="s1">                channel TEXT,</span>
<span class="s1">                </span>
<span class="s1">                -- Basic temporal properties</span>
<span class="s1">                start_time REAL,</span>
<span class="s1">                end_time REAL,</span>
<span class="s1">                duration REAL,</span>
<span class="s1">                start_time_hms TEXT,       -- formatted time (HH:MM:SS)</span>
<span class="s1">                stage TEXT,</span>
<span class="s1">                cycle TEXT,                -- sleep cycle</span>
<span class="s1">                method TEXT,</span>
<span class="s1">                        </span>
<span class="s1">                -- Frequency band information</span>
<span class="s1">                freq_band TEXT,            -- Full text representation (e.g. &quot;9-12Hz&quot;)</span>
<span class="s1">                freq_lower REAL,           -- Lower bound of frequency band (e.g. 9.0)</span>
<span class="s1">                freq_upper REAL,           -- Upper bound of frequency band (e.g. 12.0)</span>
<span class="s1">                        </span>
<span class="s1">                -- Amplitude metrics</span>
<span class="s1">                min_amp REAL,          -- minimum amplitude</span>
<span class="s1">                max_amp REAL,          -- maximum amplitude</span>

<span class="s1">                peak2peak_amp REAL,    -- peak-to-peak amplitude</span>

<span class="s1">                -- Processing metadata         </span>
<span class="s1">                processing_timestamp TEXT,</span>
<span class="s1">                n_fft_sec INTEGER,</span>
<span class="s1">                </span>
<span class="s1">                CONSTRAINT event_chan_time UNIQUE (event_type, channel, start_time, method, freq_lower, freq_upper, stage)</span>
<span class="s1">            )&#39;&#39;&#39;</span><span class="p">)</span>

            <span class="c1"># Create tracking table for batch processing</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            CREATE TABLE IF NOT EXISTS processing_status (</span>
<span class="s1">                channel TEXT,</span>
<span class="s1">                event_type TEXT,</span>
<span class="s1">                json_file TEXT,</span>
<span class="s1">                processed BOOLEAN DEFAULT 0,</span>
<span class="s1">                attempts INTEGER DEFAULT 0,</span>
<span class="s1">                last_attempt_time TEXT,</span>
<span class="s1">                success BOOLEAN DEFAULT 0,</span>
<span class="s1">                error_message TEXT,</span>
<span class="s1">                        </span>
<span class="s1">                PRIMARY KEY (channel, event_type)</span>
<span class="s1">            )&#39;&#39;&#39;</span><span class="p">)</span>

            <span class="c1"># Create indexes for efficient querying</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;CREATE INDEX IF NOT EXISTS idx_event_type ON events(event_type)&#39;</span><span class="p">)</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;CREATE INDEX IF NOT EXISTS idx_channel ON events(channel)&#39;</span><span class="p">)</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;CREATE INDEX IF NOT EXISTS idx_timerange ON events(start_time, end_time)&#39;</span><span class="p">)</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;CREATE INDEX IF NOT EXISTS idx_stage ON events(stage)&#39;</span><span class="p">)</span>
            
            
            <span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

            <span class="c1"># If database didn&#39;t exist, log creation</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">db_exists</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created new database at: </span><span class="si">{</span><span class="n">db_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="k">return</span> <span class="n">db_path</span>
        <span class="c1"># Use the safe database operation</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_database_operation</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">init_db</span><span class="p">)</span></div>


    
    <span class="k">def</span><span class="w"> </span><span class="nf">_safe_database_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_path</span><span class="p">,</span> <span class="n">operation_func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Safely perform a database operation with proper connection handling&quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">sqlite3</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">operation_func</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Database error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">conn</span><span class="p">:</span>
                <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>



<div class="viewcode-block" id="ParalEvents.import_parameters_csv_to_database">
<a class="viewcode-back" href="../../turtlewave_hdEEG.html#turtlewave_hdEEG.eventprocessor.ParalEvents.import_parameters_csv_to_database">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">import_parameters_csv_to_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">csv_file</span><span class="p">,</span> <span class="n">db_path</span><span class="p">,</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import event parameters from an existing CSV file into SQLite database.</span>
<span class="sd">        Supports multiple event types and incremental updates.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        csv_file : str</span>
<span class="sd">            Path to existing parameters CSV file</span>
<span class="sd">        db_path : str</span>
<span class="sd">            Path to SQLite database</span>
<span class="sd">        append : bool</span>
<span class="sd">            If True, adds to existing database without replacing existing entries</span>
<span class="sd">            If False, replaces any existing entries with the same UUID</span>
<span class="sd">                </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Summary of the operation with counts of added, updated, and skipped rows</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">sqlite3</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>
        
        <span class="c1"># Clean memory before starting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clean_memory</span><span class="p">()</span>  
        <span class="c1"># Initialize database if needed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">db_path</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize_sqlite_database</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
        
        <span class="c1"># Check if the file exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">csv_file</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CSV file not found: </span><span class="si">{</span><span class="n">csv_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="s2">&quot;CSV file not found&quot;</span><span class="p">,</span> <span class="s2">&quot;added&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;skipped&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        
        <span class="c1"># Track statistics</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;added&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;skipped&quot;</span><span class="p">:</span> <span class="mi">0</span>
        <span class="p">}</span>
        
        <span class="c1"># Read the CSV file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reading parameters from CSV: </span><span class="si">{</span><span class="n">csv_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># First determine how many rows to skip (header plus statistics)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
                
            <span class="c1"># Find the header row (contains &#39;Start time&#39;)</span>
            <span class="n">header_row</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;Start time&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">header_row</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>
            
            <span class="k">if</span> <span class="n">header_row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Could not find header row in CSV&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="s2">&quot;Could not find header row&quot;</span><span class="p">,</span> <span class="s2">&quot;added&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;skipped&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
            
            <span class="c1"># Check if there are statistic rows after the header</span>
            <span class="n">has_stat_rows</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">header_row</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
                <span class="n">next_line</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">header_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Check if the next line starts with &quot;Mean&quot; or contains statistical summaries</span>
                <span class="k">if</span> <span class="n">next_line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Mean&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;Mean&#39;</span> <span class="ow">in</span> <span class="n">next_line</span><span class="p">:</span>
                    <span class="n">has_stat_rows</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Skip header row and 4 statistic rows</span>
            <span class="n">skiprows</span> <span class="o">=</span> <span class="n">header_row</span> <span class="o">+</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">has_stat_rows</span> <span class="k">else</span> <span class="n">header_row</span>
            
            <span class="c1"># Read the CSV, skipping header and statistics</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="n">skiprows</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;CSV file contains no data rows&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="s2">&quot;Empty CSV file&quot;</span><span class="p">,</span> <span class="s2">&quot;added&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;skipped&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s2"> parameter rows from CSV&quot;</span><span class="p">)</span>
            
            <span class="c1"># Define database operation function</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">process_csv_data</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
                <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
                <span class="c1"># Determine event type from CSV filename or content</span>
                <span class="n">event_type</span> <span class="o">=</span> <span class="s2">&quot;spindle&quot;</span>  <span class="c1"># Default</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="s1">&#39;slow_wave&#39;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="ow">or</span> <span class="s1">&#39;slowwave&#39;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="ow">or</span> <span class="s1">&#39;sw&#39;</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
                    <span class="n">event_type</span> <span class="o">=</span> <span class="s2">&quot;slow_wave&quot;</span>
                <span class="k">elif</span> <span class="s1">&#39;spindle&#39;</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
                    <span class="n">event_type</span> <span class="o">=</span> <span class="s2">&quot;spindle&quot;</span>

                <span class="c1"># Override event_type if &#39;Event type&#39; column exists in CSV</span>
                <span class="k">if</span> <span class="s1">&#39;Event type&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="c1"># Use the first non-null value in the Event type column</span>
                    <span class="n">event_types</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Event type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">event_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">event_type</span> <span class="o">=</span> <span class="n">event_types</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Importing parameters for event type: </span><span class="si">{</span><span class="n">event_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Map column names from CSV to database columns</span>
                <span class="n">column_mapping</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;Start time&#39;</span><span class="p">:</span> <span class="s1">&#39;start_time&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Start time (HH:MM:SS)&#39;</span><span class="p">:</span> <span class="s1">&#39;start_time_hms&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;End time&#39;</span><span class="p">:</span> <span class="s1">&#39;end_time&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Stage&#39;</span><span class="p">:</span> <span class="s1">&#39;stage&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Cycle&#39;</span><span class="p">:</span> <span class="s1">&#39;cycle&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Event type&#39;</span><span class="p">:</span> <span class="s1">&#39;event_type&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Channel&#39;</span><span class="p">:</span> <span class="s1">&#39;channel&#39;</span><span class="p">,</span>                
                    <span class="s1">&#39;Duration (s)&#39;</span><span class="p">:</span> <span class="s1">&#39;duration&#39;</span><span class="p">,</span>                
                    <span class="s1">&#39;Min. amplitude (uV)&#39;</span><span class="p">:</span><span class="s1">&#39;min_amp&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Max. amplitude (uV)&#39;</span><span class="p">:</span> <span class="s1">&#39;max_amp&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Peak-to-peak amplitude (uV)&#39;</span><span class="p">:</span> <span class="s1">&#39;peak2peak_amp&#39;</span><span class="p">,</span>
                    <span class="c1">#&#39;RMS (uV)&#39;: &#39;rms&#39;,</span>
                    <span class="c1">#&#39;Power (uV^2)&#39;: &#39;power&#39;,</span>
                    <span class="c1">#&#39;Peak power frequency (Hz)&#39;: &#39;peak_power_freq&#39;,</span>
                    <span class="c1">#&#39;Energy (uV^2s)&#39;: &#39;energy&#39;,</span>
                    <span class="c1">#&#39;Peak energy frequency&#39;: &#39;peak_energy_freq&#39;,</span>
                    <span class="s1">&#39;UUID&#39;</span><span class="p">:</span> <span class="s1">&#39;uuid&#39;</span>
                <span class="p">}</span>
                
                <span class="c1"># Create a list of columns that exist in the dataframe</span>
                <span class="n">existing_columns</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">db_columns</span> <span class="o">=</span> <span class="p">[]</span>
                
                <span class="k">for</span> <span class="n">csv_col</span><span class="p">,</span> <span class="n">db_col</span> <span class="ow">in</span> <span class="n">column_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">csv_col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="n">existing_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">csv_col</span><span class="p">)</span>
                        <span class="n">db_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">db_col</span><span class="p">)</span>
                
                <span class="c1"># Add processing timestamp</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;processing_timestamp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span>
                <span class="n">existing_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;processing_timestamp&#39;</span><span class="p">)</span>
                <span class="n">db_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;processing_timestamp&#39;</span><span class="p">)</span>
                
                <span class="c1"># Extract frequency band from filename if possible</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>
                <span class="n">freq_band</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
                <span class="n">freq_lower</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">freq_upper</span> <span class="o">=</span> <span class="kc">None</span>
                
                <span class="c1"># Try to extract frequency from filename (e.g., spindle_parameters_Moelle2011_9.0-12.0Hz_NREM2NREM3.csv)</span>
                <span class="k">if</span> <span class="s2">&quot;_&quot;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="ow">and</span> <span class="s2">&quot;Hz&quot;</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
                    <span class="n">parts</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s2">&quot;Hz&quot;</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
                            <span class="n">freq_band</span> <span class="o">=</span> <span class="n">part</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="c1"># Handle formats like &quot;9-12Hz&quot; or &quot;9.0-12.0Hz&quot;</span>
                                <span class="n">freq_parts</span> <span class="o">=</span> <span class="n">freq_band</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;Hz&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq_parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                    <span class="n">freq_lower</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">freq_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                                    <span class="n">freq_upper</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">freq_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not parse frequency bounds from </span><span class="si">{</span><span class="n">freq_band</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                            <span class="k">break</span>
                
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;freq_band&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_band</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;freq_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_lower</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;freq_upper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_upper</span>
                
                <span class="n">existing_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;freq_band&#39;</span><span class="p">)</span>
                <span class="n">existing_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;freq_lower&#39;</span><span class="p">)</span>
                <span class="n">existing_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;freq_upper&#39;</span><span class="p">)</span>
                
                <span class="n">db_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;freq_band&#39;</span><span class="p">)</span>
                <span class="n">db_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;freq_lower&#39;</span><span class="p">)</span>
                <span class="n">db_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;freq_upper&#39;</span><span class="p">)</span>
                
                <span class="c1"># Extract method from filename if possible</span>
                <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
                <span class="k">if</span> <span class="s2">&quot;_&quot;</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
                    <span class="n">parts</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># Typically the format is spindle_parameters_METHOD_freq_stages.csv</span>
                        <span class="n">method</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">method</span>
                <span class="n">existing_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">)</span>
                <span class="n">db_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">)</span>
                
                <span class="c1"># Set event_type from our detection</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;event_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_type</span>
                <span class="k">if</span> <span class="s1">&#39;event_type&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">db_columns</span><span class="p">:</span>
                    <span class="n">existing_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;event_type&#39;</span><span class="p">)</span>
                    <span class="n">db_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;event_type&#39;</span><span class="p">)</span>

                <span class="c1"># Check for UUID column, which is essential for avoiding duplicates</span>
                <span class="n">uuid_col</span> <span class="o">=</span> <span class="s1">&#39;UUID&#39;</span> <span class="k">if</span> <span class="s1">&#39;UUID&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="s1">&#39;uuid&#39;</span> <span class="k">if</span> <span class="s1">&#39;uuid&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="kc">None</span>
                
                <span class="c1"># If no UUID column, create one</span>
                <span class="k">if</span> <span class="n">uuid_col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No UUID column found, creating UUIDs based on channel and time&quot;</span><span class="p">)</span>
                    <span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">))</span>
                    <span class="p">]</span>
                    <span class="n">uuid_col</span> <span class="o">=</span> <span class="s1">&#39;uuid&#39;</span>
                    <span class="n">existing_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;uuid&#39;</span><span class="p">)</span>
                    <span class="n">db_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;uuid&#39;</span><span class="p">)</span>
                
                <span class="c1"># Check if the required columns for uniqueness constraint exist</span>
                <span class="k">if</span> <span class="s1">&#39;Channel&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="s1">&#39;Start time&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Missing required columns for uniqueness check&quot;</span><span class="p">)</span>
                    
                <span class="c1"># Pre-check existing events by unique constraint (event_type, channel, start_time, method)</span>
                <span class="c1"># rather than just UUID to avoid constraint violations</span>
                <span class="n">existing_events</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">append</span> <span class="ow">and</span> <span class="s1">&#39;Channel&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s1">&#39;Start time&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="c1"># Get all unique combinations of event_type, channel, start_time</span>
                    <span class="n">channels</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">start_times</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Start time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    
                    <span class="c1"># Build a query to get existing events matching these combinations</span>
                    <span class="n">query_parts</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">query_params</span> <span class="o">=</span> <span class="p">[]</span>
                    
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)):</span>
                        <span class="n">freq_lower</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;freq_lower&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;freq_lower&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="kc">None</span>
                        <span class="n">freq_upper</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;freq_upper&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;freq_upper&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="kc">None</span>
                        <span class="n">stage</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;Stage&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="kc">None</span>

                        <span class="n">query_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;(event_type = ? AND channel = ? AND start_time = ? AND method = ? AND freq_lower = ? AND freq_upper = ? AND stage = ?)&quot;</span><span class="p">)</span>
                        <span class="n">query_params</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">event_type</span><span class="p">,</span> <span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">start_times</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">method</span><span class="p">,</span> <span class="n">freq_lower</span><span class="p">,</span> <span class="n">freq_upper</span><span class="p">,</span> <span class="n">stage</span><span class="p">])</span>
                    
                    <span class="k">if</span> <span class="n">query_parts</span><span class="p">:</span>
                        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;SELECT event_type, channel, start_time, method, freq_lower, freq_upper, stage FROM events WHERE </span><span class="si">{</span><span class="s1">&#39; OR &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">query_parts</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">query_params</span><span class="p">)</span>
                        
                        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">():</span>
                            <span class="c1"># Create a tuple of (event_type, channel, start_time. method) to check against</span>
                            <span class="n">existing_events</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">6</span><span class="p">]))</span>
                        
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">existing_events</span><span class="p">)</span><span class="si">}</span><span class="s2"> existing entries matching event type, channel, and start time&quot;</span><span class="p">)</span>
                
                <span class="c1"># Mark rows that exist in the database based on the uniqueness constraint</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;exists_in_db&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">event_type</span><span class="p">,</span> 
                        <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Channel&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)),</span> 
                        <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Start time&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> 
                        <span class="n">method</span><span class="p">,</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;freq_lower&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;freq_upper&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Stage&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">))</span>
                        <span class="p">)</span> <span class="ow">in</span> <span class="n">existing_events</span><span class="p">,</span> 
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>




                <span class="c1"># # If appending, we need to check which rows already exist in the database</span>
                <span class="c1"># if append and uuid_col:</span>
                <span class="c1">#     # Get all UUIDs from the dataframe</span>
                <span class="c1">#     all_uuids = df[uuid_col].astype(str).tolist()</span>
                    
                <span class="c1">#     # Check which UUIDs already exist in the database</span>
                <span class="c1">#     placeholders = &#39;,&#39;.join([&#39;?&#39; for _ in all_uuids])</span>
                <span class="c1">#     cursor.execute(f&quot;SELECT uuid FROM events WHERE uuid IN ({placeholders})&quot;, all_uuids)</span>
                <span class="c1">#     existing_uuids = {row[0] for row in cursor.fetchall()}</span>
                    
                <span class="c1">#     self.logger.info(f&quot;Found {len(existing_uuids)} existing entries in database&quot;)</span>
                    
                <span class="c1">#     # Mark rows that already exist in the database</span>
                <span class="c1">#     df[&#39;exists_in_db&#39;] = df[uuid_col].apply(lambda x: str(x) in existing_uuids)</span>
                <span class="c1"># else:</span>
                <span class="c1">#     # If not appending, mark all rows as not existing</span>
                <span class="c1">#     df[&#39;exists_in_db&#39;] = False</span>
                
                <span class="c1"># Process each row based on whether it exists and append mode</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;[&#39;</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]:</span>
                        <span class="c1"># Sometimes stage might be a string representation of a list like &quot;[&#39;NREM2&#39;, &#39;NREM3&#39;]&quot;</span>
                        <span class="c1"># Try to convert it to a proper list then join</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="kn">import</span><span class="w"> </span><span class="nn">ast</span>
                            <span class="n">stage_list</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">])</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stage_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stage_list</span><span class="p">)</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="c1"># If conversion fails, keep as is</span>
                            <span class="k">pass</span>
                    
                    <span class="c1"># Skip existing rows when in append mode</span>
                    <span class="k">if</span> <span class="n">append</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;exists_in_db&#39;</span><span class="p">]:</span>
                        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;skipped&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">continue</span>

                    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">row</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">existing_columns</span><span class="p">]</span>

                    <span class="c1"># Handle NaN values</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                        <span class="c1"># Check if value is NaN (using pandas or numpy&#39;s isnan)</span>
                        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;isnan&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">isnan</span><span class="p">()):</span>
                            <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Convert NaN to None (which becomes NULL in SQLite)</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">append</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;exists_in_db&#39;</span><span class="p">]:</span>
                            <span class="c1"># Skip existing rows when in append mode</span>
                            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;skipped&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">append</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;exists_in_db&#39;</span><span class="p">]:</span>
                            <span class="c1"># Update existing row when not in append mode</span>
                            <span class="n">update_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">db_columns</span> <span class="k">if</span> <span class="n">col</span> <span class="o">!=</span> <span class="s1">&#39;uuid&#39;</span><span class="p">]</span>
                            <span class="n">update_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">if</span> <span class="n">db_columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;uuid&#39;</span><span class="p">]</span>
                            
                            <span class="c1"># Update based on the unique constraint, not just UUID</span>
                            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                            UPDATE events</span>
<span class="s2">                            SET </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s1"> = ?&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">update_columns</span><span class="p">])</span><span class="si">}</span>
<span class="s2">                            WHERE event_type = ? AND channel = ? AND start_time = ? AND method = ?</span>
<span class="s2">                                AND freq_lower = ? AND freq_upper = ? AND stage = ?</span>
<span class="s2">                            &quot;&quot;&quot;</span><span class="p">,</span> <span class="n">update_values</span> <span class="o">+</span> <span class="p">[</span>
                                <span class="n">event_type</span><span class="p">,</span> 
                                <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Channel&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> 
                                <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Start time&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> 
                                <span class="n">method</span><span class="p">,</span>
                                <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;freq_lower&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;freq_upper&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Stage&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
                                    <span class="p">])</span>
                            
                            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;updated&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Insert new row - use REPLACE to handle any constraint violations</span>
                            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                            INSERT OR REPLACE INTO events</span>
<span class="s2">                            (</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_columns</span><span class="p">)</span><span class="si">}</span><span class="s2">)</span>
<span class="s2">                            VALUES (</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;?&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">db_columns</span><span class="p">])</span><span class="si">}</span><span class="s2">)</span>
<span class="s2">                            &quot;&quot;&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
                            
                            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;added&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing row: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;skipped&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                
                <span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Database updated: </span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;added&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> added, </span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;updated&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> updated, </span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;skipped&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> skipped&quot;</span><span class="p">)</span>
                

                <span class="c1"># Update processing status with handling for both channels with events and empty channels</span>
                <span class="k">if</span> <span class="s1">&#39;Channel&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">processed_channels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
                    
                    <span class="c1"># Add channels that have events in the CSV</span>
                    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">processed_channels</span><span class="p">:</span>
                        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                        INSERT OR REPLACE INTO processing_status</span>
<span class="s1">                        (channel, event_type, processed, success, attempts, last_attempt_time)</span>
<span class="s1">                        VALUES (?, ?, 1, 1, 1, datetime(&#39;now&#39;))</span>
<span class="s1">                        &#39;&#39;&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="n">event_type</span><span class="p">))</span>
                    
                    <span class="c1"># Try to identify empty channels from JSON filenames</span>
                    <span class="c1"># Note: This assumes the CSV file name contains information to identify related JSON files</span>
                    <span class="n">csv_basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>
                    <span class="n">parts</span> <span class="o">=</span> <span class="n">csv_basename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="c1"># For CSVs like: spindle_parameters_Ferrarelli2007_9-12Hz_NREM2NREM3.csv</span>
                        <span class="c1"># Matching JSONs like: spindles_Ferrarelli2007_9-12Hz_NREM2NREM3_E101.json</span>
                        
                        <span class="c1"># Extract the method and frequency-stage parts</span>
                        <span class="n">method</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># Ferrarelli2007</span>
                        <span class="n">freq_stage</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>  <span class="c1"># [&#39;9-12Hz&#39;, &#39;NREM2NREM3&#39;]</span>
                        <span class="n">freq_stage_str</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">freq_stage</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                        
                        <span class="c1"># Construct pattern to find related JSON files</span>
                        <span class="n">json_pattern</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">event_type</span><span class="si">}</span><span class="s2">s_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">freq_stage_str</span><span class="si">}</span><span class="s2">_*&quot;</span>
                        
                        <span class="c1"># Find JSON files matching the pattern</span>
                        <span class="n">json_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>
                        <span class="n">all_json_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">json_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">json_pattern</span><span class="si">}</span><span class="s2">.json&quot;</span><span class="p">))</span>
                        
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Looking for JSON files matching pattern: </span><span class="si">{</span><span class="n">json_pattern</span><span class="si">}</span><span class="s2">.json&quot;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_json_files</span><span class="p">)</span><span class="si">}</span><span class="s2"> matching JSON files&quot;</span><span class="p">)</span>

                        <span class="c1"># Extract channel names from JSON files</span>
                        <span class="n">empty_channels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">all_json_files</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="c1"># Extract channel name from filename</span>
                                <span class="c1"># Assuming format like &quot;spindles_method_freq_stage_CHANNELNAME.json&quot;</span>
                                <span class="n">channel_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.json&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                                <span class="c1"># Skip if channel already in processed_channels</span>
                                <span class="k">if</span> <span class="n">channel_name</span> <span class="ow">in</span> <span class="n">processed_channels</span><span class="p">:</span>
                                    <span class="k">continue</span>
                                
                                <span class="c1"># Read JSON file to check if it&#39;s empty</span>
                                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                                    <span class="n">content</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                                    
                                <span class="c1"># If JSON file contains an empty array, add to empty_channels</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">empty_channels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">channel_name</span><span class="p">)</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found empty JSON file for channel: </span><span class="si">{</span><span class="n">channel_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error checking JSON file </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
                        
                        <span class="c1"># Add empty channels to processing_status</span>
                        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">empty_channels</span><span class="p">:</span>
                            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                            INSERT OR REPLACE INTO processing_status</span>
<span class="s1">                            (channel, event_type, processed, success, attempts, last_attempt_time, error_message)</span>
<span class="s1">                            VALUES (?, ?, 1, 1, 1, datetime(&#39;now&#39;), &#39;No events detected&#39;)</span>
<span class="s1">                            &#39;&#39;&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="n">event_type</span><span class="p">))</span>
            
                        <span class="k">if</span> <span class="n">empty_channels</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recorded </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">empty_channels</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels with no events: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">empty_channels</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="c1"># Add empty channels count to stats</span>
                        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;empty_channels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">empty_channels</span><span class="p">)</span>
                    
                    <span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

                <span class="c1"># Get total count</span>
                <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT COUNT(*) FROM events&quot;</span><span class="p">)</span>
                <span class="n">total_count</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total parameters in database: </span><span class="si">{</span><span class="n">total_count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="k">return</span> <span class="n">stats</span>
            <span class="c1"># Use the safe database operation</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_database_operation</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">process_csv_data</span><span class="p">)</span>
    
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing CSV: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">traceback</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="s2">&quot;added&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;updated&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;skipped&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span></div>
</div>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Tancy Kao.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>